# State - Состояние
* Позволяет объектам менять поведение в зависимости от внутреннего состояния.
* Извне создаётся впечатление, что изменился класс объекта.

### Конечный автомат (машина состояний, стейт-машина)
* Основная идея концепции конечного автомата в том, что программа может находиться в одном из нескольких состояний, которые всё время сменяют друг друга.
* Набор этих состояний, а также переходов между ними, предопределён и конечен.
* Находясь в разных состояниях, программа может по-разному реагировать на одни и те же события, которые происходят с ней.

### Аналогия из реального мира
* Есть объект Документ.
* Он может находится в одном из нескольких состояний: Черновик, Модерация, Опубликован.
* В каждом из этих состояний операция Опубликовать будет работать по-разному:
  * Из черновика он отправит документ на модерацию.
  * Из модерации он отправит документ в публикацию (только если это делает администратор).
  * В опубликованном состоянии метод не будет делать ничего.

### Решаемые проблемы
* Имеется множество алгоритмов для работы с различными состояниями, тесно переплетённых в одном месте.
  * Сложно и багоопасно менять логику переходов, а также добавлять новые состояния и переходы.
* В каждом методе используется развесистый условный оператор для определения состояния объекта и выполнения требуемой операции.
* Дублирование кода для похожих состояний и переходов.
  * Паттерн Состояние позволяет реализовать иерархию состояний и избавиться от дублирования кода.

### Решение
* Вынести состояния и их поведения в отдельные классы.
* Изначальный класс, вместо выполнения всех алгоритмов, будет играть роль контекста, делегируя объекту-состоянию выполнение работы.
* Для замены состояния достаточно подставить в контекст другой объект-состояние.
* У состояний должен быть общий интерфейс. Благодаря этому:
  * Контекст не будет зависеть от конкретных классов состояний.
  * Можно будет изменять и добавлять новые состояния, не трогая код контекста (поддержка OCP).

### Диаграмма классов
1. `Context`. Контекст хранит ссылку на объект состояния и делегирует ему часть работы, зависящей от состояний.  
Контекст работает с этим объектом через общий интерфейс состояний.  
Контекст должен иметь метод для присваивания ему нового объекта-состояния.
2. `State`. Состояние описывает общий интерфейс для всех конкретных состояний.
3. `ConcreteStates`. Конкретные состояния реализуют поведения, связанные с определённым состоянием контекста.  
Иногда приходится создавать целые иерархии классов состояний, чтобы обобщить дублирующий код.  
Состояние может иметь обратную ссылку на объект контекста.  
Через неё не только удобно получать из контекста нужную информацию, но и осуществлять смену его состояния.
4. И контекст, и объекты конкретных состояний могут решать, когда и какое следующее состояние будет выбрано.  
Чтобы переключить состояние, нужно подать другой объект-состояние в контекст.

### Недостатки
* Может неоправданно и значительно усложнить код, если состояний немного и (или) они редко меняются.
* Поведение может зависеть от приватных полей или методов контекста. Варианты решения:
  * Оставить поведение внутри контекста, вызывая его из объекта состояния.
  * Сделать классы состояний вложенными в класс контекста, тогда они получат доступ ко всем приватным членам контекста.

### Примеры использования
* Когда есть объект, поведение которого значительно меняется в зависимости от его внутреннего состояния:
  * Документ - в работе, отправлен на согласование, согласован.
  * Заказ - создан, оплачен, собран, выдан.
  * Аккаунт пользователя - зарегистрирован, подтверждён, удалён.

### Примеры в .NET
Примеры реализации конечных автоматов, а не паттерна Состояние:
* `CommunicationObject` реализует конечный автомат перехода между состояниями WCF клиента: `Created`, `Opening`, `Opened`, `Closing`, `Closed`, `Faulted`.
* `Task` реализует конечный автомат перехода между состояниями задачи: `Created`, `WaitingForActivation`, `WaitingToRun`, `Running`, `RunToCompletion`, `Canceled`, `Faulted`.

### Состояние VS Стратегия
| Состояние                                                   | Стратегия                                                  |
|-------------------------------------------------------------|------------------------------------------------------------|
| **Цель**: Инкапсулировать поведение, зависящее от состояния | **Цель**: Инкапсулировать алгоритм                         |
| _В каком состоянии находится объект?_                       | _Как объект выполняет определённую задачу?_                |
| Состояния хранят в себе ссылку на контекст                  | Стратегии, как правило, не знают о контексте               |
| Состояния знают друг о друге и могут переключать сами себя  | Стратегии не знают друг о друге                            |
| Контекст сам создаёт объекты-состояния                      | Контекст получает объекты-стратегии извне, через параметры |
Оба паттерна используют композицию, чтобы менять поведение основного объекта, делегируя работу вложенным объектам-помощникам.  
Состояние можно рассматривать как надстройку над стратегией.
